[TOC]

# 为什么写这个学习文档

1. 大一时候就已经自学过python，不过真正考试时候是C语言，大二以后也是一直在C++摸爬滚打，能略懂一些皮毛，但是最近又要拿起来python来做一些RL的工作，索性写一下学习笔记，不过应该不会上传代码，因为还是比较喜欢直接在shell里面写，打开方便，不用运行，还得写一大堆注释什么的
2. [python学习教程](https://py.qizhen.xyz)里面的前言部分也很打动我，我觉得确实是一件比较有意思的事
3. 训练模型太慢了，可以趁机学学语法
4. 以后也许会出C++ 或者其他语法的？还是挺想学一门 JS来做一些前端的。
5. 好了，开始吧，感觉在计算机相关的所有事情只有立下决心是最容易的 :joy:

**PS**:不想费劲天天链接了，想看的去docs里面我会写

- 感觉真的要潜下心来真的学到一些别人学不到的东西了，感觉只是比所谓的大部分人强还是远远不够的
- 我还有太多的时间去学习，那就全部记下来，全部背住，感觉真的很需要进入一种学习心流， 不再管那些奇奇怪怪的事
- 诶，但是有一说一，我觉得这个python教程是真不错，真不错，虽然python还没完全学完，但是也看了差不多，目前感觉知识树主要还是多线程，异步并发，还有异常处理（虽然对于我们不是很重要，但是将来的工程肯定要用）
- 最重要后面刚好是我想学的前端的内容，等这波强化学习过一过，我一定要找机会学学 JS，嘿嘿
- 对了，还有C++，这尊大神，感觉真的是严谨到恶心的语言，诶，还有一些奇怪的语法，还是再看看。尤其是多线程的了解一定要深入哇，后面还要试着用继承重构一下雷达代码，有点想把雷达以及重定位封装成一个库了
- 这一说起来感觉能看的东西又有很多了，一直想要配置一个nvim来着，基地还有一个nvidia jetson没有用，要跑跑相机试试，相机反而在目前没怎么用过就是。
- 哦对，按优先级来说，那个大模型算法入门必备还是很优先的，虽然涉及到的很多内容之前都有所了解。不过话说回来cuda编写这个很早以前就提及的知识树一直没有点亮，前两天看到程楠楠在看才想起来
- 后面还得看看通信代码，自己重构一下吧
- 还有好多好多哇，求知欲真是害死猫，之前还一度想要深入学习网安部分，不过今天看到**吴瀚清**真的羡煞我也。我也想变厉害啊:sob:
- 真的仔细想想发现还有好多空缺的知识库，想起来之前的内核编译了，记得某个博主说过，你会编译linux内核一般，但是要是会harmony的就厉害，但是我感觉应该都是一个道理，至少在哲学上:smile_cat:

## 具体内容

### 元组和列表

`list1=['两点水','twowter','liangdianshui',123]` 对于字符串来说两个撇和一个撇是一致的

```shell
>>> print(list)
['name']
>>> list = ["name"]
>>> print(list)
['name']
>>> list =  ["name","age","city"]
>>> list[0:2] = '11' , '22'
>>> print(list)
['11', '22', 'city']
>>> list[0:2] = ['11','22']
>>> ls
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'ls' is not defined
>>> print(list)
['11', '22', 'city']
>>> list.append("ll")
>>> print(list)

```



### 类的实例化和直接使用类：

出于编程规范来看：

- 对于直接实例化的类来说 我们在定义类的方法我们建议使用如下格式：

  ```python
  class Animal():
  	num = 10
  	
  	@classmethod
  	def give_name(cls,name_):
  		cls.name = name_
          
  Animal.give_name("11")
  			
  ```

  

  对于类的实例化也就是创建类的对象

  ```python
  class ClassA(object):
  	name = 11
  	
  	def var1(self):
  		print(self.name)
  		
  a = ClassA()
  a.var1()
  
  def NewClassmethod(self):
      print(self.name)
  
  a.var1 = NewClassMethhod
  ```

  由此即可对比出类的实例化与类的直接使用的区别，大概主要就是`@classmethod`

  来表示类方法，以及通过类方法的传递参数`cls  \ self`

  **类可以作为一个模版，创建改变读写对象对这个模版不会产生任何的影响**

  ```
  
  ```

  

### 装饰器

```python
@dec
def f():
    ...
#等价于
def f():
    ...
f = dec(f)
#也就是把f作为参数传进去，最后给f赋值
```

今天晚上要加油哇，先搭建一个tree的目录结构
待会对强化学习的整体架构进行一个大的整理，可以考虑把train env step完全分开，工程量还是很大的，不过感觉一直以来主要问题还是没有逼自己去把很大的代码拆开来吧，还是要多想想

### numpy

```shell
>>> arr = np.zeros((9,3),dtype = np.int8)
>>> print(arr)
[[0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]]
>>> print(type(arr[0][0]))
<class 'numpy.int8'>
>>> 

```

